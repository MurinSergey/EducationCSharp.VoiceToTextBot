await using var audioFileStream = File.Create(downloadPath); чем отличается от using (var audioFileStream = File.Create(downloadPath)) {};

Оба варианта обеспечивают освобождение ресурсов после использования, но есть ключевые различия:
1. **Синтаксис и область действия**:
    - `using (var audioFileStream = File.Create(downloadPath)) { ... }` - классический синтаксис, ресурс освобождается при выходе из блока `using`
    - `await using var audioFileStream = File.Create(downloadPath);` - объявление с использованием `await using` и объявления переменной на уровне области видимости (появилось в C# 8.0)

2. **Асинхронное освобождение**:
    - Обычный `using` вызывает синхронный `Dispose()`
    - `await using` вызывает асинхронный `DisposeAsync()`, что полезно для операций освобождения ресурсов, которые могут быть долгими (например, операции ввода-вывода)

3. **Поведение при исключениях**:
   Оба гарантируют освобождение ресурсов, но `await using` делает это асинхронно.

4. **Требования к типу**:
    - Для `using` требуется реализация `IDisposable`
    - Для `await using` требуется реализация `IAsyncDisposable` (хотя компилятор может использовать и `IDisposable` через адаптер)

В вашем конкретном случае с `File.Create()` (который возвращает `FileStream`, реализующий оба интерфейса), разница будет минимальна, но `await using` предпочтительнее в асинхронном коде, так как позволяет не блокировать поток при освобождении ресурсов.